{"version":3,"file":"ui.cjs.production.min.js","sources":["../src/@types/core.ts","../src/utils/error.ts","../src/utils/data.ts","../src/server/connection.ts","../src/engine/dom.ts","../src/engine/compute.ts","../src/core/directives.ts","../src/core/directives/on.ts","../src/core/component.ts","../src/engine/compile.ts","../src/engine/render.ts","../src/utils/lazy.ts","../src/index.ts","../src/utils/reset.ts","../src/core/index.ts"],"sourcesContent":["export type Directives = Record<string, (props: DirectiveProps) => void>;\n\nexport interface DirectiveProps {\n    el: HTMLElement;\n    parts: string[];\n    data: DirectiveData;\n    node?: UINode;\n}\n\nexport type KeyedEvent = KeyboardEvent | MouseEvent | TouchEvent;\n\nexport interface DirectiveData {\n    compute: (event?: Event) => any;\n    value: string;\n}\n\nexport interface UINode {\n    directives: Record<string, DirectiveData>;\n    el: HTMLElement;\n    type: UINodeType;\n}\n\nexport enum UINodeType {\n    NULL = -1,\n    STATIC = 0,\n    DYNAMIC = 1\n}\n\nexport interface LeafUIConfig {\n    el: HTMLElement;\n    data: Record<string, any>;\n    methods: string[];\n    id: string;\n    path: string;\n    requestMethod: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD';\n    component: string;\n}\n","export const error = (\n    err: string,\n    expression?: string,\n    el?: HTMLElement\n): void => {\n    let message = `LeafUI Error: \"${err}\"`;\n    if (expression) message += `\\n\\nExpression: \"${expression}\"`;\n    if (el) message += `\\nElement:`;\n    console.warn(message, el);\n};\n","import Component from './../core/component';\nimport { LeafUIConfig } from './../@types/core';\n\nexport const eventDirectivePrefixRE = (): RegExp => /on|@/gim;\nexport const rawDirectiveSplitRE = (): RegExp => /:|\\./gim;\n\nexport const hasDirectiveRE = (): RegExp => {\n    return new RegExp(\n        `(ui-|${Object.keys(DIRECTIVE_SHORTHANDS).join('|')})\\\\w+`,\n        'gim'\n    );\n};\n\nexport const expressionPropRE = (prop: string): RegExp => {\n    // Utilizes \\b (word boundary) for prop differentiation.\n    // Fails when next character is a \\w (Word).\n    return new RegExp(`\\\\b${prop}\\\\b`, 'gim');\n};\n\nexport enum DIRECTIVE_SHORTHANDS {\n    '@' = 'on',\n    ':' = 'bind'\n}\n\nexport function arraysMatch(a: any[], b: any[]) {\n    return (\n        Array.isArray(a) &&\n        Array.isArray(b) &&\n        a.length === b.length &&\n        a.every((val, index) => val === b[index])\n    );\n}\n\ndeclare global {\n    interface Window {\n        leafUI: {\n            rootEl?: HTMLElement;\n            component: Component;\n        };\n        _leafUIConfig: LeafUIConfig;\n    }\n\n    interface HTMLElement {\n        component: Component;\n        compile: () => void;\n    }\n}\n\nwindow.leafUI = window.leafUI || {};\n","import Dom from './../engine/dom';\nimport { error } from './../utils/error';\n\nexport default class Connection {\n    protected static headers: Record<string, string>;\n\n    public static connect(\n        type: string,\n        uiData: Record<string, any>,\n        dom: typeof Dom\n    ) {\n        const pageState: Record<string, any> = {};\n        const component: HTMLElement = uiData.element.closest('[ui-state]');\n        const componentData = JSON.parse(component?.getAttribute('ui-state') ?? '{}');\n        const components = document.querySelectorAll('[ui-state]');\n\n        components.forEach((i) => {\n            const attr = JSON.parse(i.getAttribute('ui-state') ?? '{}');\n            pageState[attr.key] = attr;\n        });\n\n        const payload = {\n            type,\n            payload: {\n                params: [],\n                method: uiData.method,\n                methodArgs: uiData.methodArgs,\n                component: componentData?.key,\n                data: pageState,\n            }\n        };\n\n        return fetch(\n            `${window.location.href}?_leaf_ui_config=${JSON.stringify(\n                payload\n            )}`,\n            {\n                method: uiData.config.method,\n                // This enables \"cookies\".\n                credentials: 'same-origin',\n                headers: {\n                    'Content-Type': 'application/json',\n                    Accept: 'text/html, application/xhtml+xml',\n                    'X-Leaf-UI': 'true',\n\n                    // set Custom Headers\n                    ...this.headers,\n\n                    // We'll set this explicitly to mitigate potential interference from ad-blockers/etc.\n                    Referer: window.location.href\n                }\n            }\n        ).then(async response => {\n            if (response.ok) {\n                response.text().then(response => {\n                    const data = JSON.parse(response);\n                    window._leafUIConfig.data = data.state;\n                    dom.diff(\n                        data.html,\n                        component.nodeName === 'HTML' || !component\n                            ? document.body!\n                            : component\n                    );\n                });\n            } else {\n                error(await response.text().then(res => res));\n            }\n        });\n    }\n}\n","import { initComponent } from './../core/component';\nimport { arraysMatch } from './../utils/data';\n\nexport default class Dom {\n    /**\n     * Get the body of an HTML string\n     *\n     * @param html The html to parse\n     * @param removeScripts Whether to remove scripts from the html\n     * @returns The body/root of the html\n     */\n    public static getBody(\n        html: string,\n        removeScripts: boolean = false,\n        nodeToReturn: 'body' | 'root' = 'body'\n    ): HTMLElement {\n        const parser = new DOMParser();\n        const dom = parser.parseFromString(html, 'text/html');\n\n        if (removeScripts === true) {\n            const scripts = dom.body.getElementsByTagName('script');\n\n            for (let i = 0; i < scripts.length; i++) {\n                scripts[i].remove();\n            }\n        }\n\n        return nodeToReturn === 'body' ? dom.body : dom.documentElement;\n    }\n\n    /**\n     * Wrap DOM node with a template element\n     */\n    public static wrap(node: Node): HTMLElement {\n        const wrapper = document.createElement('x-leafui-wrapper');\n        wrapper.appendChild(node);\n        return wrapper;\n    }\n\n    /**\n     * Parse string to DOM\n     *\n     * @param html The html to parse\n     */\n    public static parse(html: string): HTMLElement {\n        const parser = new DOMParser();\n        const dom = parser.parseFromString(html, 'text/html');\n\n        return dom.getRootNode().firstChild as HTMLElement;\n    }\n\n    /**\n     * Get the type for a node\n     * @param  {HTMLElement} node The node\n     * @return {String} The type\n     */\n    public static getNodeType(node: HTMLElement): string {\n        if (node.nodeType === 3) return 'text';\n        if (node.nodeType === 8) return 'comment';\n        return node.tagName.toLowerCase();\n    }\n\n    /**\n     * Get the content from a node\n     * @param  {Node}   node The node\n     * @return {String}      The type\n     */\n    public static getNodeContent(node: HTMLElement) {\n        if (node.children && node.children.length > 0) return null;\n        return node.textContent;\n    }\n\n    /**\n     * Diff the DOM from a string and an element\n     *\n     * @param newNode The new node\n     * @param oldNode The old node\n     * @returns The diffed node\n     */\n    public static diff(newNode: string, oldNode: HTMLElement): void {\n        if (newNode.includes('<html')) {\n            if (typeof window !== 'undefined') {\n                oldNode = window.document.documentElement;\n            }\n        }\n\n        const structuredNewNode =\n            oldNode instanceof HTMLHtmlElement\n                ? Dom.getBody(newNode, false, 'root')\n                : oldNode.nodeName === 'BODY'\n                ? Dom.getBody(newNode, false)\n                : Dom.getBody(newNode, true).children[0];\n        const structuredOldNode = oldNode;\n\n        Dom.diffElements(structuredNewNode as HTMLElement, structuredOldNode);\n    }\n\n    /**\n     * Diff the DOM from two elements\n     *\n     * @param newNode The new node\n     * @param oldNode The old node\n     * @returns The diffed node\n     */\n    public static diffElements(\n        newNode: HTMLElement,\n        oldNode: HTMLElement\n    ): void {\n        const newNodes = Array.prototype.slice.call(newNode.children);\n        const oldNodes = Array.prototype.slice.call(oldNode.children);\n\n        let count = oldNodes.length - newNodes.length;\n\n        if (count > 0) {\n            for (; count > 0; count--) {\n                oldNodes[oldNodes.length - count].parentNode.removeChild(\n                    oldNodes[oldNodes.length - count]\n                );\n            }\n        }\n\n        for (let index = 0; index < newNodes.length; index++) {\n            const node = newNodes[index];\n\n            if (!oldNodes[index]) {\n                const newNodeClone = node.cloneNode(true);\n                oldNode.appendChild(newNodeClone);\n                initComponent(newNodeClone);\n                continue;\n            }\n\n            if (\n                node instanceof HTMLScriptElement &&\n                oldNodes[index] instanceof HTMLScriptElement\n            ) {\n                if (\n                    node.src !== oldNodes[index].src ||\n                    node.innerHTML !== oldNodes[index].innerHTML\n                ) {\n                    const newNodeClone = node.cloneNode(true);\n                    oldNodes[index].parentNode.replaceChild(\n                        newNodeClone,\n                        oldNodes[index]\n                    );\n                }\n\n                continue;\n            }\n\n            if (\n                !arraysMatch(\n                    Object.values(node.parentNode?.attributes ?? {}),\n                    Object.values(oldNodes[index].parentNode?.attributes ?? {})\n                )\n            ) {\n                for (\n                    let nIndex = 0;\n                    nIndex < node.parentNode.attributes?.length;\n                    nIndex++\n                ) {\n                    const attribute = node.parentNode.attributes[nIndex];\n                    oldNodes[index]?.parentNode?.setAttribute(\n                        attribute.name,\n                        attribute.value\n                    );\n                }\n            }\n\n            if (\n                Dom.getNodeType(node) !== Dom.getNodeType(oldNodes[index]) ||\n                !arraysMatch(\n                    Object.keys(oldNodes[index]?.attributes) ?? [],\n                    Object.keys(node.attributes)\n                ) ||\n                oldNodes[index]?.innerHTML !== node.innerHTML\n            ) {\n                const newNodeClone = node.cloneNode(true);\n\n                if (!oldNodes[index].parentNode) {\n                    oldNodes[index].replaceWith(newNodeClone);\n                    initComponent(newNodeClone);\n                } else {\n                    oldNodes[index].parentNode.replaceChild(\n                        newNodeClone,\n                        oldNodes[index]\n                    );\n                    initComponent(newNodeClone);\n                }\n\n                continue;\n            }\n\n            // If content is different, update it\n            const templateContent = Dom.getNodeContent(node);\n            if (\n                templateContent &&\n                templateContent !== Dom.getNodeContent(oldNodes[index])\n            ) {\n                oldNodes[index].textContent = templateContent;\n            }\n\n            if (\n                oldNodes[index].children.length > 0 &&\n                node.children.length < 1\n            ) {\n                oldNodes[index].innerHTML = '';\n                continue;\n            }\n\n            if (\n                oldNodes[index].children.length < 1 &&\n                node.children.length > 0\n            ) {\n                const fragment = document.createDocumentFragment();\n                Dom.diffElements(node, fragment as any);\n                oldNodes[index].appendChild(fragment);\n                continue;\n            }\n\n            if (node.children.length > 0) {\n                Dom.diffElements(node, oldNodes[index]);\n            }\n        }\n    }\n}\n","import { error } from '../utils/error';\nimport Connection from './../server/connection';\nimport Dom from './dom';\n\nexport const compute = (\n    expression: string,\n    el?: HTMLElement,\n    refs: Record<string, HTMLElement> = {}\n): ((event?: Event) => any) => {\n    const specialPropertiesNames = ['$el', '$emit', '$event', '$refs', '$dom'];\n\n    // This \"revives\" a function from a string, only using the new Function syntax once during compilation.\n    // This is because raw function is ~50,000x faster than new Function\n    const computeFunction = new Function(\n        `return (${specialPropertiesNames.join(',')}) => {\n            const method = ${JSON.stringify(expression)}.split('(')[0];\n            const methodArgs = ${JSON.stringify(expression)}.substring(${JSON.stringify(expression)}.indexOf('(') + 1, ${JSON.stringify(expression)}.lastIndexOf(')'));\n\n            if (!window._leafUIConfig.methods.includes(method)) {\n                return error(new ReferenceError(method + ' is not defined'), method, $el);\n            }\n\n            (${\n                Connection.connect\n            })('callMethod', { element: $el, method, methodArgs, config: window._leafUIConfig }, $dom);\n        }`\n    )();\n\n    const emit = (\n        name: string,\n        options?: CustomEventInit,\n        dispatchGlobal = true\n    ) => {\n        const event = new CustomEvent(name, options);\n        const target = dispatchGlobal ? window : el || window;\n\n        target.dispatchEvent(event);\n    };\n\n    return (event?: Event) => {\n        try {\n            return computeFunction(el, emit, event, refs, Dom);\n        } catch (err) {\n            error(err as string, expression, el);\n        }\n    };\n};\n","import { DirectiveProps, Directives } from './../@types/core';\n// import { bindDirective } from './directives/bind';\n// import { modelDirective } from './directives/model';\nimport { onDirective } from './directives/on';\n\nexport const directives: Directives = {\n    // BIND: bindDirective,\n    // MODEL: modelDirective,\n    ON: onDirective,\n};\n\nexport const renderDirective = (\n    props: DirectiveProps,\n    directives: Directives\n): void => {\n    directives[props.parts[0].toUpperCase()](props);\n};\n","import { DirectiveProps, KeyedEvent } from './../../@types/core';\n\nexport const onDirective = ({ el, parts, data }: DirectiveProps): void => {\n    const options: Record<string, boolean> = {};\n    const globalScopeEventProps = ['outside', 'global'];\n    const eventProps = parts.slice(2);\n    const EVENT_REGISTERED_FLAG = `__on_${parts[1]}_registered`;\n\n    // @ts-expect-error: We're adding a custom property to the element\n    if (el[EVENT_REGISTERED_FLAG]) return;\n\n    const target = globalScopeEventProps.some(prop =>\n        String(eventProps).includes(prop)\n    )\n        ? window\n        : el;\n\n    const handler = (event: Event) => {        \n        if (eventProps.length > 0) {\n            if (\n                event instanceof KeyboardEvent &&\n                /\\d/gim.test(String(eventProps))\n            ) {\n                const whitelistedKeycodes: number[] = [];\n                eventProps.forEach(eventProp => {\n                    // @ts-expect-error: eventProp can be a string, but isNaN only accepts number\n                    if (!isNaN(eventProp)) {\n                        whitelistedKeycodes.push(Number(eventProp));\n                    }\n                });\n\n                if (!whitelistedKeycodes.includes(event.keyCode)) return;\n            }\n\n            // Parse event modifiers based on directive prop\n            if (eventProps.includes('prevent')) event.preventDefault();\n            if (eventProps.includes('stop')) event.stopPropagation();\n            if (eventProps.includes('self')) {\n                if (event.target !== el) return;\n            }\n            /* istanbul ignore next */\n            if (eventProps.includes('outside')) {\n                if (el.contains(event.target as Node)) return;\n                if (el.offsetWidth < 1 && el.offsetHeight < 1) return;\n            }\n\n            if (eventProps.includes('enter') || eventProps.includes('meta')) {\n                if ((event as KeyboardEvent).key === 'Enter') {\n                    data.compute(event);\n                }\n            }\n\n            if (\n                (eventProps.includes('ctrl') &&\n                    (event as KeyedEvent).ctrlKey) ||\n                (eventProps.includes('alt') && (event as KeyedEvent).altKey) ||\n                (eventProps.includes('shift') &&\n                    (event as KeyedEvent).shiftKey) ||\n                (eventProps.includes('left') &&\n                    'button' in event &&\n                    (event as MouseEvent).button === 0) ||\n                (eventProps.includes('middle') &&\n                    'button' in event &&\n                    (event as MouseEvent).button === 1) ||\n                (eventProps.includes('right') &&\n                    'button' in event &&\n                    (event as MouseEvent).button === 2)\n            ) {\n                data.compute(event);\n            }\n        } else {\n            data.compute(event);\n        }\n    };\n\n    options.once = eventProps.includes('once');\n    options.passive = eventProps.includes('passive');\n\n    target.addEventListener(parts[1], handler, options);\n\n    // @ts-expect-error: We're adding a custom property to the element\n    el[EVENT_REGISTERED_FLAG] = true;\n};\n","import { UINode } from './../@types/core';\nimport { compile } from '../engine/compile';\nimport render from '../engine/render';\nimport { directives } from './directives';\n\nexport default class Component {\n    public uiNodes: UINode[] = [];\n\n    constructor() {\n        this.uiNodes = [];\n    }\n\n    public mount(el: HTMLElement | string) {\n        const rootEl =\n            el instanceof HTMLElement\n                ? el\n                : document.querySelector<HTMLElement>(el) || document.body;\n\n        this.uiNodes = compile(rootEl);\n        this.render();\n        rootEl['component'] = this;\n\n        window.leafUI = {\n            rootEl,\n            component: this\n        };\n\n        return this;\n    }\n\n    /**\n     * Force renders the DOM based on props\n     * @param {string[]=} props - Array of root level properties in state\n     * @returns {undefined}\n     */\n    public render() {\n        render(this.uiNodes, directives);\n    }\n}\n\nexport const initComponent = (element: Element) =>\n    new Component().mount(element as HTMLElement);\n","import { DirectiveData, UINode, UINodeType } from '../@types/core';\nimport { compute } from './compute';\nimport { DIRECTIVE_SHORTHANDS } from '../utils/data';\n\nexport const flattenElementChildren = (\n    rootElement: HTMLElement,\n    ignoreRootElement = false\n): HTMLElement[] => {\n    const collection: HTMLElement[] = [];\n\n    if (!ignoreRootElement) {\n        collection.push(rootElement);\n    }\n\n    for (const childElement of rootElement.children as any) {\n        if (childElement instanceof HTMLElement) {\n            collection.push(\n                ...flattenElementChildren(\n                    childElement,\n                    childElement.attributes.length === 0\n                )\n            );\n        }\n    }\n\n    return collection;\n};\n\nexport const collectRefs = (\n    element: HTMLElement | Document = document\n): Record<string, HTMLElement> => {\n    const refDirective = 'ui-ref';\n    const refElements: NodeListOf<HTMLElement> = element.querySelectorAll(\n        `[${refDirective}]`\n    );\n    const refs: Record<string, HTMLElement> = {};\n\n    refElements.forEach(refElement => {\n        const name = refElement.getAttribute(refDirective);\n\n        if (name) {\n            refs[name] = refElement;\n        }\n    });\n\n    return refs;\n};\n\nexport const initDirectives = (\n    el: HTMLElement\n): Record<string, DirectiveData> => {\n    const directives: Record<string, DirectiveData> = {};\n    const refs = collectRefs();\n\n    // @ts-ignore\n    for (const { name, value } of el.attributes) {\n        const hasDirectivePrefix = name.startsWith('ui-');\n        const hasDirectiveShorthandPrefix = Object.keys(\n            DIRECTIVE_SHORTHANDS\n        ).some(shorthand => name.startsWith(shorthand));\n\n        if (!(hasDirectivePrefix || hasDirectiveShorthandPrefix)) {\n            continue;\n        }\n\n        const directiveData = {\n            compute: compute(value, el, refs),\n            value\n        };\n\n        // Handle normal and shorthand directives=\n        const directiveName = hasDirectivePrefix\n            ? name.slice('ui-'.length)\n            : // @ts-ignore\n              `${DIRECTIVE_SHORTHANDS[name[0]]}:${name.slice(1)}`;\n\n        directives[directiveName.toLowerCase()] = directiveData;\n    }\n\n    return directives;\n};\n\nexport const createASTNode = (el: HTMLElement): UINode | undefined => {\n    const directives = initDirectives(el);\n    const hasDirectives = Object.keys(directives).length > 0;\n    const node = { el, directives, type: UINodeType.STATIC };\n\n    return hasDirectives ? node : undefined;\n};\n\nexport const compile = (\n    el: HTMLElement,\n    ignoreRootElement = false\n): UINode[] => {\n    const uiNodes: UINode[] = [];\n    const elements = flattenElementChildren(el, ignoreRootElement);\n\n    elements.forEach(element => {\n        const newASTNode = createASTNode(element);\n\n        if (newASTNode) {\n            uiNodes.push(newASTNode);\n        }\n    });\n\n    return uiNodes;\n};\n","import lazy from './../utils/lazy';\nimport { renderDirective } from './../core/directives';\nimport { rawDirectiveSplitRE } from './../utils/data';\nimport { Directives, UINode, UINodeType } from './../@types/core';\n\nconst render = (\n    uiNodes: UINode[],\n    directives: Directives,\n): void => {\n    const legalDirectiveNames = Object.keys(directives);\n    const LAZY_MODE_TIMEOUT = 25;\n\n    lazy(LAZY_MODE_TIMEOUT, function*() {\n        for (const node of uiNodes) {\n            if (node.type === UINodeType.NULL) continue;\n            const isStatic = node.type === UINodeType.STATIC;\n            if (isStatic) node.type = UINodeType.NULL;\n            yield;\n\n            if (!isStatic) continue;\n\n            for (const [directiveName, directiveData] of Object.entries(\n                node.directives\n            )) {\n                const rawDirectiveName = directiveName.split(\n                    rawDirectiveSplitRE()\n                )[0];\n\n                if (\n                    !legalDirectiveNames.includes(\n                        rawDirectiveName.toUpperCase()\n                    )\n                )\n                    continue;\n                yield;\n\n                // If affected, then push to render queue\n                if (isStatic) {\n                    const directiveProps = {\n                        el: node.el,\n                        parts: directiveName.split(rawDirectiveSplitRE()),\n                        data: directiveData,\n                        node,\n                    };\n\n                    renderDirective(directiveProps, directives);\n\n                    // [TODO] Remove this after testing\n                    delete node.directives[directiveName];\n                }\n            }\n        }\n    })();\n};\n\nexport default render;\n","/**\n * @author Aiden Bai <hello@aidenybai.com>\n * @package lucia\n */\n// Lazy allows us to delay render calls if the main thread is blocked\n// This is kind of like time slicing in React but less advanced\n// It's a generator function that yields after a certain amount of time\n// This allows the browser to render other things while the generator is running\n// It's a bit like a setTimeout but it's more accurate\n\nexport const lazy = (\n  threshold: number,\n  generatorFunction: () => Generator<undefined, void, unknown>,\n): (() => void) => {\n  const generator = generatorFunction();\n  return function next() {\n    const start = performance.now();\n    let task = null;\n    do {\n      task = generator.next();\n    } while (performance.now() - start < threshold && !task.done);\n\n    if (task.done) return;\n    setTimeout(next);\n  };\n};\n\nexport default lazy;\n","import { init } from './core';\nimport { monkeyPatchDomSetAttributeToAllowAtSymbols } from './utils/reset';\nexport * from './@types';\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    monkeyPatchDomSetAttributeToAllowAtSymbols();\n    init();\n\n    document.querySelectorAll('[ui-lazy]').forEach(el => {\n        el.removeAttribute('ui-lazy');\n    });\n});\n","/**\n * @author Caleb Porzio\n * @package livewire/livewire\n */\nexport function monkeyPatchDomSetAttributeToAllowAtSymbols() {\n    // Because morphdom may add attributes to elements containing \"@\" symbols\n    // like in the case of an Alpine `@click` directive, we have to patch\n    // the standard Element.setAttribute method to allow this to work.\n    let original = Element.prototype.setAttribute;\n\n    let hostDiv = document.createElement('div');\n\n    Element.prototype.setAttribute = function newSetAttribute(name, value) {\n        if (!name.includes('@')) {\n            return original.call(this, name, value);\n        }\n\n        hostDiv.innerHTML = `<span ${name}=\"${value}\"></span>`;\n\n        let attr = (hostDiv.firstElementChild)!.getAttributeNode(name)!;\n\n        (hostDiv.firstElementChild)!.removeAttributeNode(attr);\n\n        this.setAttributeNode(attr);\n    };\n}\n","import Component from './component';\n\n/**\n * Initialize Your Leaf UI root component\n * @param {HTMLElement|Document} element - Root element to find uninitialized components\n */\nexport const init = (element: HTMLElement | Document = document): void => {\n    const leafUI = new Component();\n    const rootElement = element instanceof Document ? element.body : element;\n\n    leafUI.mount(rootElement);\n};\n"],"names":["UINodeType","DIRECTIVE_SHORTHANDS","error","err","expression","el","message","console","warn","Connection","connect","type","uiData","dom","pageState","component","element","closest","componentData","JSON","parse","getAttribute","document","querySelectorAll","forEach","i","attr","key","fetch","window","location","href","stringify","payload","params","method","methodArgs","data","config","credentials","headers","Content-Type","Accept","X-Leaf-UI","this","Referer","then","response","ok","_context","text","_leafUIConfig","state","diff","html","nodeName","body","res","arraysMatch","a","b","Array","isArray","length","every","val","index","leafUI","Dom","getBody","removeScripts","nodeToReturn","DOMParser","parseFromString","scripts","getElementsByTagName","remove","documentElement","wrap","node","wrapper","createElement","appendChild","getRootNode","firstChild","getNodeType","nodeType","tagName","toLowerCase","getNodeContent","children","textContent","newNode","oldNode","includes","structuredNewNode","HTMLHtmlElement","diffElements","newNodes","prototype","slice","call","oldNodes","count","parentNode","removeChild","HTMLScriptElement","src","innerHTML","newNodeClone","cloneNode","replaceChild","Object","values","_node$parentNode","attributes","_oldNodes$index$paren2","nIndex","_node$parentNode$attr2","attribute","_oldNodes$index","_oldNodes$index$paren3","setAttribute","name","value","keys","_oldNodes$index2","_oldNodes$index3","templateContent","fragment","createDocumentFragment","initComponent","replaceWith","compute","refs","computeFunction","Function","join","emit","options","dispatchGlobal","event","CustomEvent","dispatchEvent","directives","ON","parts","eventProps","EVENT_REGISTERED_FLAG","target","some","prop","String","once","passive","addEventListener","KeyboardEvent","test","whitelistedKeycodes","eventProp","isNaN","push","Number","keyCode","preventDefault","stopPropagation","contains","offsetWidth","offsetHeight","ctrlKey","altKey","shiftKey","button","renderDirective","props","toUpperCase","Component","uiNodes","_proto","mount","rootEl","HTMLElement","querySelector","ignoreRootElement","flattenElementChildren","rootElement","collection","childElement","newASTNode","refElements","refElement","collectRefs","hasDirectivePrefix","startsWith","hasDirectiveShorthandPrefix","shorthand","directiveData","directiveName","initDirectives","STATIC","undefined","createASTNode","compile","render","generator","legalDirectiveNames","_iterator","NULL","isStatic","_i","entries","_Object$entries$_i","rawDirectiveName","split","directiveProps","generatorFunction","next","start","performance","now","task","done","setTimeout","original","hostDiv","Element","firstElementChild","getAttributeNode","removeAttributeNode","setAttributeNode","Document","init","removeAttribute"],"mappings":"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"}